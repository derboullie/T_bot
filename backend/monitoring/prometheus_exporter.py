"""Prometheus Metrics Exporter for Bot Monitoring.

Exports metrics for external monitoring systems like Prometheus/Grafana.
"""

from typing import Dict, Optional
from datetime import datetime
from loguru import logger

try:
    from prometheus_client import Counter, Gauge, Histogram, Summary, generate_latest, REGISTRY
    PROM_AVAILABLE = True
except ImportError:
    PROM_AVAILABLE = False
    logger.warning("prometheus_client not available. Install with: poetry add prometheus-client")


class PrometheusExporter:
    """
    Export trading bot metrics to Prometheus.
    
    Metrics include:
    - Trade counts and success rates
    - Portfolio value and P&L
    - Strategy performance
    - System health
    """
    
    def __init__(self, enabled: bool = True):
        """
        Initialize Prometheus exporter.
        
        Args:
            enabled: Whether to enable metrics export
        """
        self.enabled = enabled and PROM_AVAILABLE
        
        if not self.enabled:
            logger.warning("Prometheus metrics disabled")
            return
            
        # Trade metrics
        self.trades_total = Counter(
            'trading_bot_trades_total',
            'Total number of trades executed',
            ['symbol', 'side', 'status']
        )
        
        self.trade_pnl = Histogram(
            'trading_bot_trade_pnl',
            'P&L per trade',
            ['symbol'],
            buckets=(-1000, -100, -10, 0, 10, 100, 1000, 10000)
        )
        
        # Portfolio metrics
        self.portfolio_value = Gauge(
            'trading_bot_portfolio_value',
            'Current portfolio value in USD'
        )
        
        self.portfolio_pnl = Gauge(
            'trading_bot_portfolio_pnl',
            'Total unrealized P&L'
        )
        
        self.position_count = Gauge(
            'trading_bot_position_count',
            'Number of open positions'
        )
        
        # Strategy metrics
        self.strategy_signals = Counter(
            'trading_bot_strategy_signals_total',
            'Signals generated by strategy',
            ['strategy', 'signal_type']
        )
        
        self.strategy_performance = Gauge(
            'trading_bot_strategy_performance',
            'Strategy performance metric',
            ['strategy', 'metric']
        )
        
        # System health
        self.cpu_usage = Gauge(
            'trading_bot_cpu_usage_percent',
            'CPU usage percentage'
        )
        
        self.memory_usage = Gauge(
            'trading_bot_memory_usage_mb',
            'Memory usage in MB'
        )
        
        self.api_latency = Histogram(
            'trading_bot_api_latency_seconds',
            'API call latency',
            ['api_name', 'endpoint'],
            buckets=(0.001, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0)
        )
        
        self.errors_total = Counter(
            'trading_bot_errors_total',
            'Total errors',
            ['error_type', 'severity']
        )
        
        logger.info("Prometheus metrics exporter initialized")
        
    def record_trade(
        self,
        symbol: str,
        side: str,
        status: str,
        pnl: Optional[float] = None
    ):
        """Record a trade."""
        if not self.enabled:
            return
            
        self.trades_total.labels(
            symbol=symbol,
            side=side,
            status=status
        ).inc()
        
        if pnl is not None:
            self.trade_pnl.labels(symbol=symbol).observe(pnl)
            
    def update_portfolio(
        self,
        value: float,
        pnl: float,
        position_count: int
    ):
        """Update portfolio metrics."""
        if not self.enabled:
            return
            
        self.portfolio_value.set(value)
        self.portfolio_pnl.set(pnl)
        self.position_count.set(position_count)
        
    def record_signal(self, strategy: str, signal_type: str):
        """Record strategy signal."""
        if not self.enabled:
            return
            
        self.strategy_signals.labels(
            strategy=strategy,
            signal_type=signal_type
        ).inc()
        
    def update_strategy_perf(
        self,
        strategy: str,
        metric: str,
        value: float
    ):
        """Update strategy performance."""
        if not self.enabled:
            return
            
        self.strategy_performance.labels(
            strategy=strategy,
            metric=metric
        ).set(value)
        
    def update_system_health(
        self,
        cpu_percent: float,
        memory_mb: float
    ):
        """Update system health metrics."""
        if not self.enabled:
            return
            
        self.cpu_usage.set(cpu_percent)
        self.memory_usage.set(memory_mb)
        
    def record_api_latency(
        self,
        api_name: str,
        endpoint: str,
        latency_seconds: float
    ):
        """Record API latency."""
        if not self.enabled:
            return
            
        self.api_latency.labels(
            api_name=api_name,
            endpoint=endpoint
        ).observe(latency_seconds)
        
    def record_error(
        self,
        error_type: str,
        severity: str = 'error'
    ):
        """Record an error."""
        if not self.enabled:
            return
            
        self.errors_total.labels(
            error_type=error_type,
            severity=severity
        ).inc()
        
    def get_metrics(self) -> bytes:
        """Get metrics in Prometheus format."""
        if not self.enabled:
            return b''
            
        return generate_latest(REGISTRY)


class HealthChecker:
    """
    Comprehensive health check system.
    
    Monitors:
    - API connections
    - Database
    - Trading engine
    - Data feeds
   

 """
    
    def __init__(self):
        """Initialize health checker."""
        self.health_status = {}
        self.last_check = None
        
    def check_all(self) -> Dict:
        """
        Run all health checks.
        
        Returns:
            Health status dict
        """
        self.last_check = datetime.now()
        
        checks = {
            'timestamp': self.last_check.isoformat(),
            'overall_status': 'healthy',
            'checks': {}
        }
        
        # Check API connections
        checks['checks']['api'] = self._check_api_health()
        
        # Check database
        checks['checks']['database'] = self._check_database()
        
        # Check data feeds
        checks['checks']['data_feed'] = self._check_data_feed()
        
        # Check trading engine
        checks['checks']['trading'] = self._check_trading_engine()
        
        # Determine overall status
        failed_checks = [
            name for name, status in checks['checks'].items()
            if status['status'] != 'healthy'
        ]
        
        if failed_checks:
            checks['overall_status'] = 'degraded' if len(failed_checks) < 2 else 'unhealthy'
            checks['failed_checks'] = failed_checks
            
        return checks
        
    def _check_api_health(self) -> Dict:
        """Check API connectivity."""
        # Placeholder - implement actual checks
        return {
            'status': 'healthy',
            'message': 'API connections operational',
            'latency_ms': 50
        }
        
    def _check_database(self) -> Dict:
        """Check database connectivity."""
        return {
            'status': 'healthy',
            'message': 'Database operational'
        }
        
    def _check_data_feed(self) -> Dict:
        """Check data feed status."""
        return {
            'status': 'healthy',
            'message': 'Data feeds active',
            'last_update': datetime.now().isoformat()
        }
        
    def _check_trading_engine(self) -> Dict:
        """Check trading engine status."""
        return {
            'status': 'healthy',
            'message': 'Trading engine operational'
        }


# Global instances
prometheus_exporter = PrometheusExporter(enabled=PROM_AVAILABLE)
health_checker = HealthChecker()
